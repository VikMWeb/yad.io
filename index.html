<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ТН 11</title>
  <style>
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: Arial, sans-serif;
      background:#f3f3f3;
      min-height:100vh;
      display:flex;
      justify-content:center;
      align-items:center;
      padding:16px;
    }
    .app{
      width:min(1100px, 100%);
      background:#fff;
      border:1px solid #ddd;
      border-radius:12px;
      box-shadow:0 8px 25px rgba(0,0,0,.06);
      overflow:hidden;
    }
    header{
      padding:14px 16px;
      border-bottom:1px solid #eee;
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
    }
    header h1{ margin:0; font-size:18px; }
    .content{
      display:grid;
      grid-template-columns: 1fr 330px;
      gap:0;
    }
    .zones{
      padding:16px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      align-items:start;
    }
    .zone{
      border:1px solid #e6e6e6;
      border-radius:12px;
      overflow:hidden;
      background:#fafafa;
      display:flex;
      flex-direction:column;
      min-height:420px;
    }
    .zone .title{
      padding:10px 12px;
      border-bottom:1px solid #eee;
      font-weight:700;
      font-size:13px;
      background:#fff;
    }
    .canvasWrap{
      padding:10px;
      display:flex;
      justify-content:center;
      align-items:flex-start;
      overflow:auto;
      height:100%;
    }
    canvas{
      background:#fff;
      border:1px dashed #ddd;
      border-radius:10px;
      max-width:100%;
      height:auto;
    }
    aside{
      border-left:1px solid #eee;
      padding:16px;
      background:#fcfcfc;
    }
    .group{
      margin-bottom:14px;
      padding:12px;
      border:1px solid #eee;
      border-radius:12px;
      background:#fff;
    }
    .group h3{
      margin:0 0 10px 0;
      font-size:14px;
    }
    .row{
      display:flex;
      gap:10px;
      align-items:center;
      margin-bottom:10px;
      flex-wrap:wrap;
    }
    .row label{
      font-size:13px;
      color:#333;
      min-width:120px;
    }
    input[type="number"], input[type="text"]{
      width:140px;
      padding:8px 10px;
      border:1px solid #ddd;
      border-radius:10px;
      outline:none;
      background:#fff;
    }
    button{
      padding:10px 12px;
      border:none;
      border-radius:12px;
      background:#1976d2;
      color:#fff;
      cursor:pointer;
      font-weight:700;
      font-size:13px;
    }
    button.secondary{ background:#5f6b7a; }
    button.danger{ background:#c62828; }
    button:disabled{
      opacity:.55;
      cursor:not-allowed;
    }
    .hint{
      font-size:12px;
      color:#666;
      margin-top:8px;
      line-height:1.35;
    }
    .pill{
      display:inline-block;
      padding:4px 8px;
      border-radius:999px;
      background:#f1f4f8;
      border:1px solid #e6e9ef;
      font-size:12px;
      color:#333;
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>ТН 11 — Зона 2: контур, заповнення, прибрати контур</h1>
      <span class="pill" id="info">—</span>
    </header>

    <div class="content">
      <div class="zones">
        <div class="zone">
          <div class="title">Зона 1 (оригінал)</div>
          <div class="canvasWrap">
            <canvas id="c1"></canvas>
          </div>
        </div>

        <div class="zone">
          <div class="title">Зона 2 (обробка)</div>
          <div class="canvasWrap">
            <canvas id="c2"></canvas>
          </div>
        </div>
      </div>

      <aside>
        <div class="group">
          <h3>Дані</h3>
          <div class="row">
            <button id="btnLoad">Завантажити фото</button>
            <input id="file" type="file" accept="image/*" hidden>
          </div>
          <div class="row">
            <label>Масштаб, %</label>
            <input id="scale" type="number" min="10" max="300" value="100">
          </div>
          <div class="hint">
            Масштаб впливає тільки на відображення (canvas). Дії нижче виконуються <b>в Зоні 2</b>.
          </div>
        </div>

        <div class="group">
          <h3>Обробка (Зона 2)</h3>
          <div class="row">
            <button id="btnGray" class="secondary">Ч/Б (Gray)</button>
            <button id="btnContour" class="secondary">Контур 0/1</button>
          </div>
          <div class="row">
            <button id="btnFill" class="secondary">Заповнити всередині контура</button>
            <button id="btnRemoveContour" class="danger">Прибрати контур</button>
          </div>
          <div class="hint">
            • <b>Контур 0/1</b> будує маску контура по поточному зображенню Зони 2 (бінаризація + контур).<br>
            • <b>Заповнити</b> — заповнює область всередині замкненого контура (працює по масці контура).<br>
            • <b>Прибрати контур</b> — повертає Зону 2 у стан <i>до</i> накладання контура.
          </div>
        </div>

        <div class="group">
          <h3>Скидання</h3>
          <div class="row">
            <button id="btnReset" class="danger">Очистити Зону 2</button>
          </div>
        </div>
      </aside>
    </div>
  </div>

<script>
(() => {
  const c1 = document.getElementById('c1');
  const c2 = document.getElementById('c2');
  const ctx1 = c1.getContext('2d', { willReadFrequently:true });
  const ctx2 = c2.getContext('2d', { willReadFrequently:true });

  const info = document.getElementById('info');
  const file = document.getElementById('file');
  const btnLoad = document.getElementById('btnLoad');
  const btnGray = document.getElementById('btnGray');
  const btnContour = document.getElementById('btnContour');
  const btnFill = document.getElementById('btnFill');
  const btnRemoveContour = document.getElementById('btnRemoveContour');
  const btnReset = document.getElementById('btnReset');
  const scaleEl = document.getElementById('scale');

  let img = new Image();
  let hasImage = false;

  // Стан Зони 2
  let zone2Base = null;          // ImageData (поточний "базовий" стан Зони 2)
  let zone2BeforeContour = null; // ImageData (стан Зони 2 до накладання контура)
  let zone2ContourMask = null;   // Uint8Array (0/1), 1 = контурний піксель

  function clampInt(v, a, b){ return Math.max(a, Math.min(b, v|0)); }

  function setCanvasSizeFromImage(canvas, w, h, scalePct){
    const s = Math.max(10, Math.min(300, Number(scalePct)||100)) / 100;
    canvas.width = Math.max(1, Math.round(w * s));
    canvas.height = Math.max(1, Math.round(h * s));
  }

  function drawImageToCanvas(canvas, ctx, image, scalePct){
    setCanvasSizeFromImage(canvas, image.naturalWidth, image.naturalHeight, scalePct);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
  }

  function updateInfo(){
    if(!hasImage){
      info.textContent = "Фото не завантажено";
      return;
    }
    info.textContent = `Зона1: ${c1.width}×${c1.height} | Зона2: ${c2.width}×${c2.height}`;
  }

  function getImageData2(){
    if(c2.width < 1 || c2.height < 1) return null;
    return ctx2.getImageData(0, 0, c2.width, c2.height);
  }

  function putImageData2(im){
    if(!im) return;
    ctx2.putImageData(im, 0, 0);
    zone2Base = ctx2.getImageData(0, 0, c2.width, c2.height);
  }

  function toGrayImageData(im){
    const d = im.data;
    for(let i=0; i<d.length; i+=4){
      const r = d[i], g = d[i+1], b = d[i+2];
      const gray = (0.299*r + 0.587*g + 0.114*b) | 0;
      d[i]=d[i+1]=d[i+2]=gray;
      d[i+3]=255;
    }
    return im;
  }

  // Бінаризація по порогу (з gray) => 0/1
  function toBinaryMaskFromGray(im, threshold=128){
    const w = im.width, h = im.height;
    const d = im.data;
    const bin = new Uint8Array(w*h);
    for(let y=0; y<h; y++){
      for(let x=0; x<w; x++){
        const i = (y*w + x);
        const p = i*4;
        const g = d[p]; // уже gray
        bin[i] = (g < threshold) ? 1 : 0; // 1 = "об'єкт" (темне)
      }
    }
    return bin;
  }

  // Контур: піксель = 1, якщо це "об'єкт" і має сусіда-фон (4-сусідство)
  function contourMaskFromBinary(bin, w, h){
    const out = new Uint8Array(w*h);
    const idx = (x,y)=> y*w+x;

    for(let y=1; y<h-1; y++){
      for(let x=1; x<w-1; x++){
        const i = idx(x,y);
        if(bin[i] !== 1) continue;
        const up = bin[idx(x,y-1)];
        const dn = bin[idx(x,y+1)];
        const lf = bin[idx(x-1,y)];
        const rt = bin[idx(x+1,y)];
        if(up===0 || dn===0 || lf===0 || rt===0){
          out[i] = 1;
        }
      }
    }
    return out;
  }

  function renderBinaryToImageData(bin, w, h){
    const im = new ImageData(w, h);
    const d = im.data;
    for(let i=0; i<bin.length; i++){
      const v = bin[i] ? 0 : 255; // 1 -> чорне, 0 -> біле
      const p = i*4;
      d[p]=d[p+1]=d[p+2]=v;
      d[p+3]=255;
    }
    return im;
  }

  function overlayContourOnImageData(im, contourMask){
    const d = im.data;
    for(let i=0; i<contourMask.length; i++){
      if(!contourMask[i]) continue;
      const p = i*4;
      d[p]=d[p+1]=d[p+2]=0; // контур чорним
      d[p+3]=255;
    }
    return im;
  }

  // Заповнення всередині контура:
  // 1) беремо бінарну маску "об'єкта"
  // 2) робимо flood fill від країв по фону, НЕ проходячи крізь контур
  // 3) все, що лишилось фоном і не "зовні" -> це "дірки" всередині -> заповнюємо в 1
  function fillInsideContour(bin, contourMask, w, h){
    const outside = new Uint8Array(w*h); // 1 = фон, який з'єднаний з краями (зовнішній)
    const qx = new Int32Array(w*h);
    const qy = new Int32Array(w*h);
    let qs = 0, qe = 0;

    const push = (x,y)=>{
      qx[qe]=x; qy[qe]=y; qe++;
    };
    const idx = (x,y)=>y*w+x;

    // стартові точки — по периметру там, де фон і не контур
    function trySeed(x,y){
      const i = idx(x,y);
      if(outside[i]) return;
      if(contourMask[i]) return; // через контур не йдемо
      if(bin[i] === 1) return;   // не фон
      outside[i] = 1;
      push(x,y);
    }

    for(let x=0; x<w; x++){ trySeed(x,0); trySeed(x,h-1); }
    for(let y=0; y<h; y++){ trySeed(0,y); trySeed(w-1,y); }

    // BFS по фону (0), зупиняємося на контурі
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    while(qs < qe){
      const x = qx[qs], y = qy[qs]; qs++;
      for(const [dx,dy] of dirs){
        const nx = x+dx, ny = y+dy;
        if(nx<0||ny<0||nx>=w||ny>=h) continue;
        const ni = idx(nx,ny);
        if(outside[ni]) continue;
        if(contourMask[ni]) continue;
        if(bin[ni] === 1) continue;
        outside[ni] = 1;
        push(nx,ny);
      }
    }

    // Заповнюємо "внутрішній фон" (фон, який НЕ outside) в об'єкт (1)
    const filled = new Uint8Array(bin); // копія
    for(let i=0; i<filled.length; i++){
      if(contourMask[i]) continue; // контур не чіпаємо тут
      if(filled[i] === 0 && outside[i] === 0){
        filled[i] = 1;
      }
    }
    return filled;
  }

  function enableButtons(on){
    btnGray.disabled = !on;
    btnContour.disabled = !on;
    btnFill.disabled = !on;
    btnRemoveContour.disabled = !on;
    btnReset.disabled = !on;
  }

  // --- UI events ---
  btnLoad.addEventListener('click', ()=> file.click());

  file.addEventListener('change', (e)=>{
    const f = e.target.files && e.target.files[0];
    if(!f) return;

    const url = URL.createObjectURL(f);
    img = new Image();
    img.onload = () => {
      hasImage = true;

      const sc = clampInt(scaleEl.value, 10, 300);
      drawImageToCanvas(c1, ctx1, img, sc);

      // Зона 2: копія Зони 1 (старт)
      c2.width = c1.width; c2.height = c1.height;
      ctx2.clearRect(0,0,c2.width,c2.height);
      ctx2.drawImage(c1, 0,0);

      zone2Base = getImageData2();
      zone2BeforeContour = null;
      zone2ContourMask = null;

      updateInfo();
      enableButtons(true);
      URL.revokeObjectURL(url);
    };
    img.src = url;
  });

  scaleEl.addEventListener('input', ()=>{
    if(!hasImage) return;
    const sc = clampInt(scaleEl.value, 10, 300);

    // Перемальовуємо Зону 1
    drawImageToCanvas(c1, ctx1, img, sc);

    // Перемальовуємо Зону 2 з останнього базового стану (zone2Base),
    // але під новий розмір треба перерахувати. Простий варіант: масштабувати поточний вигляд.
    // (Якщо хочеш "ідеально", треба зберігати оригінал у повній роздільній та перераховувати.)
    const snap = ctx2.getImageData(0,0,c2.width,c2.height);

    c2.width = c1.width; c2.height = c1.height;
    ctx2.clearRect(0,0,c2.width,c2.height);

    // тимчасовий canvas для масштабування
    const t = document.createElement('canvas');
    t.width = snap.width; t.height = snap.height;
    t.getContext('2d').putImageData(snap,0,0);
    ctx2.drawImage(t, 0,0, c2.width, c2.height);

    zone2Base = getImageData2();
    zone2BeforeContour = null;
    zone2ContourMask = null;

    updateInfo();
  });

  btnGray.addEventListener('click', ()=>{
    if(!hasImage) return;
    let im = getImageData2();
    if(!im) return;
    im = toGrayImageData(im);
    putImageData2(im);

    // будь-які попередні маски контура стають неактуальними
    zone2BeforeContour = null;
    zone2ContourMask = null;
  });

  btnContour.addEventListener('click', ()=>{
    if(!hasImage) return;

    let im = getImageData2();
    if(!im) return;

    // запам'ятовуємо стан ДО контура, щоб "Прибрати контур" повертав назад
    zone2BeforeContour = new ImageData(new Uint8ClampedArray(im.data), im.width, im.height);

    // гарантуємо gray
    im = toGrayImageData(im);

    const w = im.width, h = im.height;

    // робимо бінаризацію і контур
    const bin = toBinaryMaskFromGray(im, 128);
    const contour = contourMaskFromBinary(bin, w, h);

    zone2ContourMask = contour;

    // показ у Зоні 2: як бінарне поле (0/1) + контур чорним
    let view = renderBinaryToImageData(bin, w, h);
    view = overlayContourOnImageData(view, contour);

    putImageData2(view);
  });

  btnFill.addEventListener('click', ()=>{
    // Заповнюємо всередині контура тільки у Зоні 2
    if(!hasImage) return;
    if(!zone2ContourMask){
      // якщо контур ще не будувався — нічого заповнювати
      return;
    }

    // беремо поточний вигляд Зони 2 і робимо з нього bin (0/1)
    let im = getImageData2();
    if(!im) return;
    im = toGrayImageData(im);

    const w = im.width, h = im.height;
    const bin = toBinaryMaskFromGray(im, 128);

    const filled = fillInsideContour(bin, zone2ContourMask, w, h);

    // показ: заповнене (0/1) + контур чорним
    let view = renderBinaryToImageData(filled, w, h);
    view = overlayContourOnImageData(view, zone2ContourMask);

    putImageData2(view);
  });

  btnRemoveContour.addEventListener('click', ()=>{
    // Прибираємо контур (повертаємо Зону 2 у стан ДО накладання контура)
    if(!hasImage) return;
    if(zone2BeforeContour){
      ctx2.putImageData(zone2BeforeContour, 0, 0);
      zone2Base = getImageData2();
    }
    zone2BeforeContour = null;
    zone2ContourMask = null;
  });

  btnReset.addEventListener('click', ()=>{
    if(!hasImage) return;
    ctx2.clearRect(0,0,c2.width,c2.height);
    zone2Base = null;
    zone2BeforeContour = null;
    zone2ContourMask = null;
  });

  enableButtons(false);
  updateInfo();
})();
</script>
</body>
  </html>
